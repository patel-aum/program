{"slug":"find-the-adjoint-of-a-matrix","title":"Find the adjoint of a matrix","trackId":4037,"tags":["Java","Python"],"contributors":["harshraj8843","aghiles-medane","joao-vitor-souza"],"contentHtml":"<h2>Write a program to find the adjoint of a matrix</h2>\n<p>The adjoint of a square matrix A is the transpose of the matrix of cofactors of A. The adjoint of a matrix A is denoted as A*.</p>\n<pre><code>Input  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n[[-3, 6, -3], [6, -12, 6], [-3, 6, -3]]\n</code></pre>\n<hr>\n<pre><code>public class Adjoints {\n\n\tstatic void getCofactors(int A[][], int temp[][], int p, int q, int n) {\n\t\tint i = 0, j = 0;\n\t\tfor (int row = 0; row &#x3C; n; row++) {\n\t\t\tfor (int col = 0; col &#x3C; n; col++) {\n\t\t\t\tif (row != p &#x26;&#x26; col != q) {\n\t\t\t\t\ttemp[i][j++] = A[row][col];\n\t\t\t\t\tif (j == n - 1) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int determinant(int A[][], int n) {\n\n\t\tif (n == 1)\n\t\t\treturn A[0][0];\n\t\tint N = A.length;\n\t\tint[][] tableTmp = new int[N][N];\n\t\tint D = 0;\n\t\t\n\t\tint sign = 1;\n\t\tfor (int f = 0; f &#x3C; n; f++) {\n\t\t\tgetCofactors(A, tableTmp, 0, f, n);\n\t\t\tD += sign * A[0][f] * determinant(tableTmp, n - 1);\n\t\t\tsign = -1 * sign;\n\t\t}\n\n\t\treturn D;\n\t}\n\n\tpublic static int[][] adjoint(int A[][]) {\n\n\t\tint N = A.length;\n\t\tint[][] adj = new int[N][N];\n\t\tif (N == 1) {\n\t\t\tadj[0][0] = 1;\n\t\t\treturn adj;\n\t\t}\n\n\t\tint sign = 1;\n\t\tint[][] temp = new int[N][N];\n\n\t\tfor (int i = 0; i &#x3C; N; i++) {\n\t\t\tfor (int j = 0; j &#x3C; N; j++) {\n\t\t\t\tgetCofactors(A, temp, i, j, N);\n\n\t\t\t\tsign = ((i + j) % 2 == 0) ? 1 : -1;\n\n\t\t\t\tadj[j][i] = (sign) * (determinant(temp, N - 1));\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\n}\n</code></pre>\n<pre><code>from typing import List\nimport numpy as np\n\n\ndef compute_adjoint_matrix(matrix: List[List[int]]) -> np.ndarray:\n    n_lines = len(matrix)\n    n_columns = len(matrix[0])\n    cofactor_matrix = np.array([])\n    if n_lines != n_columns:\n        print(\"Input a square matrix!\")\n        return\n    for line in range(n_lines):\n        for column in range(n_columns):\n            minor_matrix = []\n            for minor_line in matrix:\n                minor_line_copy = minor_line.copy()\n                minor_line_copy.pop(column)\n                minor_matrix.append(minor_line_copy)\n            minor_matrix.pop(line)\n            cofactor_matrix = np.append(\n                cofactor_matrix, (-1) ** (line + column) * np.linalg.det(minor_matrix)\n            )\n\n    return cofactor_matrix.reshape((n_lines, n_columns)).T\n\n\nprint(compute_adjoint_matrix([[1, 2, 3], \n                              [4, 5, 6], \n                              [7, 8, 9]]))\n\n\"\"\" Output:\n[[ -3.   6.  -3.]\n [  6. -12.   6.]\n [ -3.   6.  -3.]]\n\"\"\"\n</code></pre>\n","markdown":"\n## Write a program to find the adjoint of a matrix\n\nThe adjoint of a square matrix A is the transpose of the matrix of cofactors of A. The adjoint of a matrix A is denoted as A<sup>\\*</sup>.\n\n```\nInput  :\n1 2 3\n4 5 6\n7 8 9\n\nOutput :\n[[-3, 6, -3], [6, -12, 6], [-3, 6, -3]]\n```\n\n---\n\n<CodeBlock slug=\"find-the-adjoint-of-a-matrix\" >\n\n```java\npublic class Adjoints {\n\n\tstatic void getCofactors(int A[][], int temp[][], int p, int q, int n) {\n\t\tint i = 0, j = 0;\n\t\tfor (int row = 0; row < n; row++) {\n\t\t\tfor (int col = 0; col < n; col++) {\n\t\t\t\tif (row != p && col != q) {\n\t\t\t\t\ttemp[i][j++] = A[row][col];\n\t\t\t\t\tif (j == n - 1) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int determinant(int A[][], int n) {\n\n\t\tif (n == 1)\n\t\t\treturn A[0][0];\n\t\tint N = A.length;\n\t\tint[][] tableTmp = new int[N][N];\n\t\tint D = 0;\n\t\t\n\t\tint sign = 1;\n\t\tfor (int f = 0; f < n; f++) {\n\t\t\tgetCofactors(A, tableTmp, 0, f, n);\n\t\t\tD += sign * A[0][f] * determinant(tableTmp, n - 1);\n\t\t\tsign = -1 * sign;\n\t\t}\n\n\t\treturn D;\n\t}\n\n\tpublic static int[][] adjoint(int A[][]) {\n\n\t\tint N = A.length;\n\t\tint[][] adj = new int[N][N];\n\t\tif (N == 1) {\n\t\t\tadj[0][0] = 1;\n\t\t\treturn adj;\n\t\t}\n\n\t\tint sign = 1;\n\t\tint[][] temp = new int[N][N];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tgetCofactors(A, temp, i, j, N);\n\n\t\t\t\tsign = ((i + j) % 2 == 0) ? 1 : -1;\n\n\t\t\t\tadj[j][i] = (sign) * (determinant(temp, N - 1));\n\t\t\t}\n\t\t}\n\t\treturn adj;\n\t}\n\n}\n```\n\n```py\nfrom typing import List\nimport numpy as np\n\n\ndef compute_adjoint_matrix(matrix: List[List[int]]) -> np.ndarray:\n    n_lines = len(matrix)\n    n_columns = len(matrix[0])\n    cofactor_matrix = np.array([])\n    if n_lines != n_columns:\n        print(\"Input a square matrix!\")\n        return\n    for line in range(n_lines):\n        for column in range(n_columns):\n            minor_matrix = []\n            for minor_line in matrix:\n                minor_line_copy = minor_line.copy()\n                minor_line_copy.pop(column)\n                minor_matrix.append(minor_line_copy)\n            minor_matrix.pop(line)\n            cofactor_matrix = np.append(\n                cofactor_matrix, (-1) ** (line + column) * np.linalg.det(minor_matrix)\n            )\n\n    return cofactor_matrix.reshape((n_lines, n_columns)).T\n\n\nprint(compute_adjoint_matrix([[1, 2, 3], \n                              [4, 5, 6], \n                              [7, 8, 9]]))\n\n\"\"\" Output:\n[[ -3.   6.  -3.]\n [  6. -12.   6.]\n [ -3.   6.  -3.]]\n\"\"\"\n```\n\n</CodeBlock>\n\n","latestUpdateDate":"2022-12-25T13:17:11Z"}